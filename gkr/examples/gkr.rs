use ark_ec::bls12::Bls12;
use ark_ec::pairing::Pairing;

use ark_std::One;
use ark_std::UniformRand;

use clap::Parser;
use dist_primitive::dpoly_comm::PolynomialCommitmentCub;

use dist_primitive::mle::PackedDenseMultilinearExtension;

use gkr::dgkr::d_gkr;
// use gkr::gkr::d_polyfill_gkr;
use gkr::gkr::local_gkr;
use gkr::gkr::SparseMultilinearExtension;

use mpc_net::LocalTestNet;
use mpc_net::MultiplexedStreamID;
use secret_sharing::pss::PackedSharingParams;
use std::hint::black_box;

use std::collections::HashMap;

type E = Bls12<ark_bls12_381::Config>;
/// f1(g,x,y)f2(x)f3(y)
#[derive(Parser)]
struct Cli {
    /// The packing size, should be 1/4 of the party size as well as a power of 2.
    #[arg(long)]
    l: usize,
    /// The depth of the circuit.
    #[arg(long)]
    depth: usize,
    /// log2 of the width of the circuit.
    #[arg(long)]
    width: usize,
}

#[cfg_attr(feature = "single_thread", tokio::main(flavor = "current_thread"))]
#[cfg_attr(not(feature = "single_thread"), tokio::main)]
async fn main() {
    let args = Cli::parse();

    // Local
    gkr_local_bench(args.width, args.depth);

    // Distributed
    gkr_distributed_bench(args.width, args.depth, args.l).await;
}

#[cfg(feature = "leader")]
async fn gkr_distributed_bench(width: usize, depth: usize, l: usize) {
    let rng = &mut ark_std::test_rng();
    let pp = PackedSharingParams::<<E as Pairing>::ScalarField>::new(l);
    let net = LocalTestNet::new_local_testnet(l * 4).await.unwrap();
    // Shares of a polynomial representing mult and add.
    let mut f1 = SparseMultilinearExtension::<<E as Pairing>::ScalarField>(HashMap::new());
    for _ in 0..((1 << width) / l) {
        f1.0.insert(
            (
                <E as Pairing>::ScalarField::rand(rng),
                <E as Pairing>::ScalarField::rand(rng),
                <E as Pairing>::ScalarField::rand(rng),
            ),
            <E as Pairing>::ScalarField::one(),
        );
    }
    let f1s_shares = vec![f1; depth];
    // Shares of a polynomial representing V.
    let poly_v =
        PackedDenseMultilinearExtension::<<E as Pairing>::ScalarField>::from_evaluations_slice(
            0,
            &(0..(1 << (width - pp.l.trailing_zeros() as usize)))
                .map(|_| <E as Pairing>::ScalarField::rand(rng))
                .collect::<Vec<_>>(),
        );
    let poly_vs_shares = vec![poly_v; depth];
    // Shares of challenge g, u, v, r. For benchmarking purposes, we generate them in advance and use them repeatedly in the protocol.
    // In the real protocol, g's shares should be generated by a f_rand protocol.
    let challenge_g: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    let challenge_u: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    let challenge_v: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    let challenge_r: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    // Polynomial commitment.
    let commit_shares = PolynomialCommitmentCub::<E>::new_single(width, &pp);

    let res = d_gkr(
        depth,
        width,
        &f1s_shares,
        &poly_vs_shares,
        &challenge_g,
        &challenge_u,
        &challenge_v,
        &challenge_r,
        &commit_shares,
        &pp,
        &net.get_leader(),
        MultiplexedStreamID::Zero,
    )
    .await
    .unwrap();
    black_box(res);
}

#[cfg(not(feature = "leader"))]
async fn gkr_distributed_bench(width: usize, depth: usize, l: usize) {
    let rng = &mut ark_std::test_rng();
    let pp = PackedSharingParams::<<E as Pairing>::ScalarField>::new(l);
    let net = LocalTestNet::new_local_testnet(l * 4).await.unwrap();
    // Shares of a polynomial representing mult and add.
    let mut f1 = SparseMultilinearExtension::<<E as Pairing>::ScalarField>(HashMap::new());
    for _ in 0..((1 << width) / l) {
        f1.0.insert(
            (
                <E as Pairing>::ScalarField::rand(rng),
                <E as Pairing>::ScalarField::rand(rng),
                <E as Pairing>::ScalarField::rand(rng),
            ),
            <E as Pairing>::ScalarField::one(),
        );
    }
    let f1s_shares = vec![f1; depth];
    // Shares of a polynomial representing V.
    let poly_v =
        PackedDenseMultilinearExtension::<<E as Pairing>::ScalarField>::from_evaluations_slice(
            0,
            &(0..(1 << (width - pp.l.trailing_zeros() as usize)))
                .map(|_| <E as Pairing>::ScalarField::rand(rng))
                .collect::<Vec<_>>(),
        );
    let poly_vs_shares = vec![poly_v; depth];
    // Shares of challenge g, u, v, r. For benchmarking purposes, we generate them in advance and use them repeatedly in the protocol.
    // In the real protocol, g's shares should be generated by a f_rand protocol.
    let challenge_g: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    let challenge_u: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    let challenge_v: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    let challenge_r: Vec<<E as Pairing>::ScalarField> = (0..width)
        .map(|_| <E as Pairing>::ScalarField::rand(rng))
        .collect::<Vec<_>>();
    // Polynomial commitment.
    let commit_shares = PolynomialCommitmentCub::<E>::new_single(width, &pp);

    let proof = net
        .simulate_network_round(
            (
                f1s_shares,
                poly_vs_shares,
                challenge_g,
                challenge_u,
                challenge_v,
                challenge_r,
                commit_shares,
            ),
            move |net,
                  (
                f1s_shares,
                poly_vs_shares,
                challenge_g,
                challenge_u,
                challenge_v,
                challenge_r,
                commit_shares,
            )| async move {
                let pp = PackedSharingParams::<<E as Pairing>::ScalarField>::new(l);
                let res = d_gkr(
                    depth,
                    width,
                    &f1s_shares,
                    &poly_vs_shares,
                    &challenge_g,
                    &challenge_u,
                    &challenge_v,
                    &challenge_r,
                    &commit_shares,
                    &pp,
                    &net,
                    MultiplexedStreamID::Zero,
                )
                .await
                .unwrap();
                black_box(res);
            },
        )
        .await;
    black_box(proof);
}

fn gkr_local_bench(width: usize, depth: usize) {
    let res = local_gkr::<E>(depth, width);
    black_box(res);
}
